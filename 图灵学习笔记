jvm 双亲委派

0.引导类加载器
|
1.ExtClassLoader
|
2.AppClassLoader
|
3.自定义类加载器

当新加载一个class时：3 向上 请求2 是否可以加载（2 如果无法加载 ，向上请求1， 1请求0），最终0也无法加载时，委托3加载


打破双亲委派
不可加载java.lang等核心package ：沙箱安全

类大小
A1[对象头(8字节)] + A2[Kclass pointer(8字节) 指向元空间该类的指针（开启压缩后为4字节）] + (A3[数组长度 4字节] 只有数组有) + B[实例数据 对象成员变量为指针(4B (不开启压缩8B)] + C[对齐填充（ 保证 (A+B+C) % 8 =0）]
计算工具:JOL

 

jps 查java进程pid
jmap -heap pid 看堆信息
jmap -histo pid 看对象信息
jmap -dump:format=b file=xxx.xx pid 导出堆dump 用jvisualvm看

-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxcc/ccc

jstack pid  看thread

top -p pid
按H 找线程ID->pid  在jastack里是nid

jstat -gc pid X(监视间隔ms) Y（监视次数）
查看ygc和ogc频率 根据分配的堆大小估算每秒进入eden的数据量，每秒进老年代的数据量
jvisualvm 内存抽样 查看大对象，找到业务代码里大对象的持有类
jvisualvm cpu抽样 查看cpu占用

元空间会触发full gc
动态年龄判断机制
老年代担保机制
大对象直接进入老年代机制

CMS 并行清理，有浮动垃圾；有参数可以清理后整理


CAS ABA问题 对策:AtomicStampedReference

jdk7 hashTable 多线程扩容：链表成环问题：头插法
jdk8 hashmap 链表转红黑树机制，链表长度 > 8 (根据泊松分布得出长度为8的概率为0.00000006)&& 容量>=64才转；扩容算法思想可用于分库分表

总线风暴：滥用volatile


有@Configureation注解的类会被cglib添加动态代理，从而在@Bean方法被调用时优先根据方法名返回BeanMap里的Bean

mybatis注册mapper动态代理：把扫描到的mapper接口注册成factoryBean，从而在getObject的时候生成动态代理

redis encoding 的内存优化
embstr  redisObject 16byte + sdshdr8 [4byte(len+free+flag+'\0') + str 44byte] = 64 byte CPU L3一个缓存行 CPU一次读取可以拿到全部数据
int     redisObject  *ptr直接存储64位以内的数据
raw

setbit 连续登录统计
  login_day05  0 1 0 1 ..... 
& login_day06  0 1 1 1 .....  -> BITOP and login_day0506  login_day05  login_day06
-------------------------------
               0 1 0 1       -> bitcount login_day0506


zk 非公平锁 ， 解锁后所有等待加锁的cli会同时请求加锁， ->惊群效应